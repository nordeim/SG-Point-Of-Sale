EEEEEEEEEEEEEEEEEEEEEEEEEE                                               [100%]
==================================== ERRORS ====================================
________ ERROR at setup of TestCompanyManager.test_get_company_success _________

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_get_company_success>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> d5a6759ef2f7, Initial schema setup - Corrected to match current ORM models.
INFO  [alembic.runtime.migration] Running upgrade  -> d5a6759ef2f7, Initial schema setup - Corrected to match current ORM models.
_______ ERROR at setup of TestCompanyManager.test_update_company_success _______

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_update_company_success>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
_ ERROR at setup of TestCompanyManager.test_update_company_duplicate_reg_no_fails _

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_update_company_duplicate_reg_no_fails>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
______ ERROR at setup of TestCustomerManager.test_create_customer_success ______

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_create_customer_success>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
_ ERROR at setup of TestCustomerManager.test_create_customer_duplicate_code_fails _

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_create_customer_duplicate_code_fails>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
____ ERROR at setup of TestCustomerManager.test_add_loyalty_points_for_sale ____

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_add_loyalty_points_for_sale>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
_________ ERROR at setup of TestCustomerManager.test_search_customers __________

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_search_customers>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
_______ ERROR at setup of TestInventoryManager.test_adjust_stock_success _______

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_adjust_stock_success>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
__ ERROR at setup of TestInventoryManager.test_create_purchase_order_success ___

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_create_purchase_order_success>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
_ ERROR at setup of TestInventoryManager.test_receive_purchase_order_items_success _

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_receive_purchase_order_items_success>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
_ ERROR at setup of TestInventoryManager.test_receive_more_than_ordered_fails __

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_receive_more_than_ordered_fails>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
_______ ERROR at setup of TestProductManager.test_create_product_success _______

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_create_product_success>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
_ ERROR at setup of TestProductManager.test_create_product_duplicate_sku_fails _

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_create_product_duplicate_sku_fails>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
_______ ERROR at setup of TestProductManager.test_update_product_success _______

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_update_product_success>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
_____ ERROR at setup of TestProductManager.test_deactivate_product_success _____

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_deactivate_product_success>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
__________ ERROR at setup of TestProductManager.test_search_products ___________

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_search_products>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
________ ERROR at setup of TestSalesManager.test_finalize_sale_success _________

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_finalize_sale_success>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
__ ERROR at setup of TestSalesManager.test_finalize_sale_insufficient_payment __

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_finalize_sale_insufficient_payment>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
___ ERROR at setup of TestSalesManager.test_finalize_sale_insufficient_stock ___

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_finalize_sale_insufficient_stock>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
____ ERROR at setup of TestUserManager.test_create_user_success_with_roles _____

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_create_user_success_with_roles>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
_ ERROR at setup of TestUserManager.test_create_user_duplicate_username_fails __

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_create_user_duplicate_username_fails>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
___________ ERROR at setup of TestUserManager.test_update_user_roles ___________

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_update_user_roles>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
________ ERROR at setup of TestUserManager.test_deactivate_user_success ________

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_deactivate_user_success>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
_________ ERROR at setup of TestProductService.test_get_by_sku_success _________

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_get_by_sku_success>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
________ ERROR at setup of TestProductService.test_get_by_sku_not_found ________

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_get_by_sku_not_found>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError
__________ ERROR at setup of TestProductService.test_search_products ___________

self = <sqlalchemy.engine.base.Connection object at 0x742a65c50a40>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>
statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x742a5ccf3500>
parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DuplicateTable: relation "companies" already exists

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: DuplicateTable

The above exception was the direct cause of the following exception:

item = <Coroutine test_search_products>

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_setup(item):
        """
        Hook called after before test setup starts, to start capturing exceptions
        as early as possible.
        """
        capture_enabled = _is_exception_capture_enabled(item)
        if capture_enabled:
            item.qt_exception_capture_manager = _QtExceptionCaptureManager()
            item.qt_exception_capture_manager.start()
>       result = yield
                 ^^^^^

lib/python3.12/site-packages/pytestqt/plugin.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/python3.12/site-packages/pytest_asyncio/plugin.py:347: in _asyncgen_fixture_wrapper
    result = event_loop.run_until_complete(setup())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
lib/python3.12/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/conftest.py:50: in setup_database
    command.upgrade(alembic_cfg, "head")
lib/python3.12/site-packages/alembic/command.py:483: in upgrade
    script.run_env()
lib/python3.12/site-packages/alembic/script/base.py:551: in run_env
    util.load_python_file(self.dir, "env.py")
lib/python3.12/site-packages/alembic/util/pyfiles.py:114: in load_python_file
    module = load_module_py(module_id, path)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/util/pyfiles.py:134: in load_module_py
    spec.loader.exec_module(module)  # type: ignore
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
migrations/env.py:133: in <module>
    run_migrations_online()
migrations/env.py:128: in run_migrations_online
    do_run_migrations(connection)
migrations/env.py:112: in do_run_migrations
    context.run_migrations()
lib/python3.12/site-packages/alembic/runtime/environment.py:946: in run_migrations
    self.get_context().run_migrations(**kw)
lib/python3.12/site-packages/alembic/runtime/migration.py:623: in run_migrations
    step.migration_fn(**kw)
migrations/versions/d5a6759ef2f7_initial_schema_setup.py:32: in upgrade
    op.create_table('companies',
lib/python3.12/site-packages/alembic/operations/ops.py:1332: in create_table
    return operations.invoke(op)
           ^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/base.py:441: in invoke
    return fn(self, operation)
           ^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/alembic/operations/toimpl.py:135: in create_table
    operations.impl.create_table(table, **kw)
lib/python3.12/site-packages/alembic/ddl/impl.py:423: in create_table
    self._exec(schema.CreateTable(table, **kw))
lib/python3.12/site-packages/alembic/ddl/impl.py:246: in _exec
    return conn.execute(construct, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1526: in _execute_ddl
    ret = self._execute_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
lib/python3.12/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
lib/python3.12/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x742a5cc9e480>
cursor = <cursor object at 0x742a5ccf7970; closed: -1>
statement = '\nCREATE TABLE sgpos.companies (\n\tid UUID NOT NULL, \n\tname VARCHAR(255) NOT NULL, \n\tregistration_number VARCHAR... UNIQUE (gst_registration_number), \n\tCONSTRAINT uq_companies_registration_number UNIQUE (registration_number)\n)\n\n'
parameters = immutabledict({})
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x742a5ccf3a40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateTable) relation "companies" already exists
E       
E       [SQL: 
E       CREATE TABLE sgpos.companies (
E       	id UUID NOT NULL, 
E       	name VARCHAR(255) NOT NULL, 
E       	registration_number VARCHAR(20) NOT NULL, 
E       	gst_registration_number VARCHAR(20), 
E       	address TEXT, 
E       	phone VARCHAR(20), 
E       	email VARCHAR(255), 
E       	base_currency VARCHAR(3) NOT NULL, 
E       	fiscal_year_start DATE, 
E       	is_active BOOLEAN NOT NULL, 
E       	created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL, 
E       	CONSTRAINT pk_companies PRIMARY KEY (id), 
E       	CONSTRAINT uq_companies_gst_registration_number UNIQUE (gst_registration_number), 
E       	CONSTRAINT uq_companies_registration_number UNIQUE (registration_number)
E       )
E       
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

lib/python3.12/site-packages/sqlalchemy/engine/default.py:943: ProgrammingError

---------- coverage: platform linux, python 3.12.3-final-0 -----------
Name                                               Stmts   Miss  Cover   Missing
--------------------------------------------------------------------------------
app/__init__.py                                        0      0   100%
app/business_logic/__init__.py                         0      0   100%
app/business_logic/dto/__init__.py                     0      0   100%
app/business_logic/dto/company_dto.py                 21      0   100%
app/business_logic/dto/customer_dto.py                26      0   100%
app/business_logic/dto/inventory_dto.py               95      0   100%
app/business_logic/dto/payment_dto.py                 23     23     0%   3-36
app/business_logic/dto/product_dto.py                 30      3    90%   28-30
app/business_logic/dto/reporting_dto.py               63     63     0%   8-93
app/business_logic/dto/sales_dto.py                   46      0   100%
app/business_logic/dto/user_dto.py                    22      0   100%
app/business_logic/managers/__init__.py                0      0   100%
app/business_logic/managers/base_manager.py            7      7     0%   3-15
app/business_logic/managers/company_manager.py        46     46     0%   3-67
app/business_logic/managers/customer_manager.py      105    105     0%   3-159
app/business_logic/managers/gst_manager.py            39     39     0%   3-83
app/business_logic/managers/inventory_manager.py     132    132     0%   3-211
app/business_logic/managers/payment_manager.py        61     61     0%   3-90
app/business_logic/managers/product_manager.py        74     74     0%   8-165
app/business_logic/managers/reporting_manager.py     136    136     0%   3-220
app/business_logic/managers/sales_manager.py          98     98     0%   5-199
app/business_logic/managers/user_manager.py           79     79     0%   3-128
app/core/__init__.py                                   0      0   100%
app/core/application_core.py                         235    164    30%   19-37, 47-52, 59-69, 76-99, 103-109, 113-115, 119-128, 132-133, 137-138, 142-143, 147-148, 153-156, 160-163, 167-170, 174-177, 181-184, 188-191, 195-198, 202-205, 209-212, 216-219, 223-226, 230-233, 238-241, 245-248, 252-255, 259-262, 266-269, 273-276, 280-283, 287-290, 294-297
app/core/async_bridge.py                              78     57    27%   28-30, 34-48, 52-61, 65-69, 72-83, 88-91, 94-100, 103-107, 110-114
app/core/config.py                                    13      0   100%
app/core/exceptions.py                                 8      0   100%
app/core/result.py                                    13      0   100%
app/integrations/__init__.py                           0      0   100%
app/main.py                                           34     34     0%   8-64
app/models/__init__.py                                10      0   100%
app/models/accounting.py                              47      0   100%
app/models/audit_log.py                               21      0   100%
app/models/base.py                                    10      0   100%
app/models/company.py                                 46      0   100%
app/models/customer.py                                21      0   100%
app/models/inventory.py                               67      0   100%
app/models/product.py                                 72      0   100%
app/models/sales.py                                   65      0   100%
app/models/user.py                                    61      1    98%   37
app/services/__init__.py                               0      0   100%
app/services/base_service.py                          85     85     0%   8-152
app/services/company_service.py                       40     40     0%   3-55
app/services/customer_service.py                      62     62     0%   3-106
app/services/inventory_service.py                     62     62     0%   3-115
app/services/payment_service.py                       34     34     0%   3-58
app/services/product_service.py                       53     53     0%   3-92
app/services/purchase_order_service.py                48     48     0%   3-97
app/services/report_service.py                        70     70     0%   9-193
app/services/sales_service.py                         26     26     0%   3-52
app/services/supplier_service.py                      41     41     0%   3-73
app/services/user_service.py                          34     34     0%   3-44
app/ui/__init__.py                                     0      0   100%
app/ui/dialogs/__init__.py                             0      0   100%
app/ui/dialogs/customer_dialog.py                     97     97     0%   3-143
app/ui/dialogs/payment_dialog.py                     131    131     0%   3-176
app/ui/dialogs/payment_method_dialog.py               74     74     0%   3-116
app/ui/dialogs/product_dialog.py                      89     89     0%   3-122
app/ui/dialogs/purchase_order_dialog.py              148    148     0%   3-183
app/ui/dialogs/receive_po_dialog.py                  104    104     0%   3-150
app/ui/dialogs/stock_adjustment_dialog.py            141    141     0%   13-180
app/ui/dialogs/user_dialog.py                        118    118     0%   3-165
app/ui/main_window.py                                 57     57     0%   10-113
app/ui/resources/__init__.py                           0      0   100%
app/ui/resources/icons/__init__.py                     0      0   100%
app/ui/views/__init__.py                               0      0   100%
app/ui/views/customer_view.py                        149    149     0%   3-211
app/ui/views/dashboard_view.py                        64     64     0%   3-94
app/ui/views/inventory_view.py                       245    245     0%   3-293
app/ui/views/payment_method_view.py                  127    127     0%   3-170
app/ui/views/pos_view.py                             185    185     0%   3-224
app/ui/views/product_view.py                         146    146     0%   3-190
app/ui/views/reports_view.py                         183    183     0%   3-237
app/ui/views/settings_view.py                        174    174     0%   3-220
app/ui/widgets/__init__.py                             0      0   100%
app/ui/widgets/kpi_widget.py                          26     26     0%   5-43
app/ui/widgets/managed_table_view.py                  40     40     0%   6-80
app/ui/widgets/searchable_table_view.py                1      1     0%   10
--------------------------------------------------------------------------------
TOTAL                                               4758   3976    16%

=========================== short test summary info ============================
ERROR tests/unit/business_logic/managers/test_company_manager.py::TestCompanyManager::test_get_company_success
ERROR tests/unit/business_logic/managers/test_company_manager.py::TestCompanyManager::test_update_company_success
ERROR tests/unit/business_logic/managers/test_company_manager.py::TestCompanyManager::test_update_company_duplicate_reg_no_fails
ERROR tests/unit/business_logic/managers/test_customer_manager.py::TestCustomerManager::test_create_customer_success
ERROR tests/unit/business_logic/managers/test_customer_manager.py::TestCustomerManager::test_create_customer_duplicate_code_fails
ERROR tests/unit/business_logic/managers/test_customer_manager.py::TestCustomerManager::test_add_loyalty_points_for_sale
ERROR tests/unit/business_logic/managers/test_customer_manager.py::TestCustomerManager::test_search_customers
ERROR tests/unit/business_logic/managers/test_inventory_manager.py::TestInventoryManager::test_adjust_stock_success
ERROR tests/unit/business_logic/managers/test_inventory_manager.py::TestInventoryManager::test_create_purchase_order_success
ERROR tests/unit/business_logic/managers/test_inventory_manager.py::TestInventoryManager::test_receive_purchase_order_items_success
ERROR tests/unit/business_logic/managers/test_inventory_manager.py::TestInventoryManager::test_receive_more_than_ordered_fails
ERROR tests/unit/business_logic/managers/test_product_manager.py::TestProductManager::test_create_product_success
ERROR tests/unit/business_logic/managers/test_product_manager.py::TestProductManager::test_create_product_duplicate_sku_fails
ERROR tests/unit/business_logic/managers/test_product_manager.py::TestProductManager::test_update_product_success
ERROR tests/unit/business_logic/managers/test_product_manager.py::TestProductManager::test_deactivate_product_success
ERROR tests/unit/business_logic/managers/test_product_manager.py::TestProductManager::test_search_products
ERROR tests/unit/business_logic/managers/test_sales_manager.py::TestSalesManager::test_finalize_sale_success
ERROR tests/unit/business_logic/managers/test_sales_manager.py::TestSalesManager::test_finalize_sale_insufficient_payment
ERROR tests/unit/business_logic/managers/test_sales_manager.py::TestSalesManager::test_finalize_sale_insufficient_stock
ERROR tests/unit/business_logic/managers/test_user_manager.py::TestUserManager::test_create_user_success_with_roles
ERROR tests/unit/business_logic/managers/test_user_manager.py::TestUserManager::test_create_user_duplicate_username_fails
ERROR tests/unit/business_logic/managers/test_user_manager.py::TestUserManager::test_update_user_roles
ERROR tests/unit/business_logic/managers/test_user_manager.py::TestUserManager::test_deactivate_user_success
ERROR tests/unit/services/test_product_service.py::TestProductService::test_get_by_sku_success
ERROR tests/unit/services/test_product_service.py::TestProductService::test_get_by_sku_not_found
ERROR tests/unit/services/test_product_service.py::TestProductService::test_search_products
26 errors in 23.54s
