# File: app/business_logic/managers/inventory_manager.py
"""Business Logic Manager for orchestrating Inventory operations."""
from __future__ import annotations
from typing import TYPE_CHECKING, List, Dict, Any, Optional
from uuid import UUID
from decimal import Decimal
import uuid as uuid_pkg

from app.core.result import Result, Success, Failure
from app.business_logic.managers.base_manager import BaseManager
from app.business_logic.dto.inventory_dto import (
    StockAdjustmentDTO, PurchaseOrderCreateDTO, PurchaseOrderDTO,
    InventorySummaryDTO, StockMovementDTO, SupplierDTO, PurchaseOrderItemDTO
)
from app.models.inventory import StockMovement, PurchaseOrder, PurchaseOrderItem
from app.models.product import Product
from sqlalchemy.orm import selectinload

if TYPE_CHECKING:
    from app.core.application_core import ApplicationCore
    from app.services.inventory_service import InventoryService
    from app.services.product_service import ProductService
    from app.services.supplier_service import SupplierService
    from app.services.purchase_order_service import PurchaseOrderService
    from app.services.user_service import UserService
    from app.services.company_service import OutletService
    from sqlalchemy.ext.asyncio import AsyncSession


class InventoryManager(BaseManager):
    """Handles high-level inventory workflows like stock takes, adjustments, and purchase orders."""
    
    @property
    def inventory_service(self) -> "InventoryService": return self.core.inventory_service
    @property
    def product_service(self) -> "ProductService": return self.core.product_service
    @property
    def supplier_service(self) -> "SupplierService": return self.core.supplier_service
    @property
    def purchase_order_service(self) -> "PurchaseOrderService": return self.core.purchase_order_service
    @property
    def user_service(self) -> "UserService": return self.core.user_service
    @property
    def outlet_service(self) -> "OutletService": return self.core.outlet_service

    async def adjust_stock(self, dto: StockAdjustmentDTO) -> Result[None, str]:
        """Performs a stock adjustment for one or more products, creating an auditable stock movement record for each change."""
        try:
            async with self.core.get_session() as session:
                for item_dto in dto.items:
                    current_stock_result = await self.inventory_service.get_stock_level(dto.outlet_id, item_dto.product_id, item_dto.variant_id, session)
                    if isinstance(current_stock_result, Failure): raise Exception(f"Failed to get current stock for {item_dto.product_id}: {current_stock_result.error}")
                    
                    quantity_change = item_dto.counted_quantity - current_stock_result.value
                    if quantity_change == 0: continue

                    adjust_result = await self.inventory_service.adjust_stock_level(dto.outlet_id, item_dto.product_id, item_dto.variant_id, quantity_change, session)
                    if isinstance(adjust_result, Failure): raise Exception(f"Failed to update inventory for {item_dto.product_id}: {adjust_result.error}")

                    movement = StockMovement(
                        company_id=dto.company_id, outlet_id=dto.outlet_id, product_id=item_dto.product_id,
                        variant_id=item_dto.variant_id, movement_type='ADJUSTMENT_IN' if quantity_change > 0 else 'ADJUSTMENT_OUT',
                        quantity_change=quantity_change, notes=dto.notes, created_by_user_id=dto.user_id, reference_type="STOCK_ADJUSTMENT"
                    )
                    log_result = await self.inventory_service.log_movement(movement, session)
                    if isinstance(log_result, Failure): raise Exception(f"Failed to log stock movement for {item_dto.product_id}: {log_result.error}")
            return Success(None)
        except Exception as e:
            return Failure(str(e))

    async def deduct_stock_for_sale(self, company_id: UUID, outlet_id: UUID, sale_items: List[Dict[str, Any]], cashier_id: UUID, session: AsyncSession) -> Result[List[StockMovement], str]:
        """Deduct stock for a finalized sale. Called by SalesManager within its atomic transaction."""
        stock_movements = []
        for item_data in sale_items:
            product: Product = item_data['product']
            if not product.track_inventory: continue
            
            adjust_result = await self.inventory_service.adjust_stock_level(
                outlet_id, product.id, item_data.get('variant_id'), -item_data['quantity'], session
            )
            if isinstance(adjust_result, Failure): return Failure(f"Insufficient stock for {product.sku}: {adjust_result.error}")

            movement = StockMovement(
                company_id=company_id, outlet_id=outlet_id, product_id=product.id, variant_id=item_data.get('variant_id'),
                movement_type='SALE', quantity_change=-item_data['quantity'], created_by_user_id=cashier_id, reference_type="SALES_TRANSACTION"
            )
            stock_movements.append(movement)
            log_result = await self.inventory_service.log_movement(movement, session)
            if isinstance(log_result, Failure): return Failure(f"Failed to log sale stock movement for {product.sku}: {log_result.error}")
        return Success(stock_movements)

    async def create_purchase_order(self, dto: PurchaseOrderCreateDTO) -> Result[PurchaseOrderDTO, str]:
        """Creates a new purchase order, including its line items."""
        try:
            async with self.core.get_session() as session:
                # FIX: Pass the session to all service calls within the transaction block.
                supplier_result = await self.supplier_service.get_by_id(dto.supplier_id, session)
                if isinstance(supplier_result, Failure) or supplier_result.value is None: raise Exception("Supplier not found.")

                po_total_amount = Decimal("0.0")
                po_items: List[PurchaseOrderItem] = []
                for item_dto in dto.items:
                    product_result = await self.product_service.get_by_id(item_dto.product_id, session)
                    if isinstance(product_result, Failure) or product_result.value is None: raise Exception(f"Product {item_dto.product_id} not found.")
                    po_items.append(PurchaseOrderItem(**item_dto.dict()))
                    po_total_amount += item_dto.quantity_ordered * item_dto.unit_cost

                po_number = dto.po_number or f"PO-{uuid_pkg.uuid4().hex[:8].upper()}"
                new_po = PurchaseOrder(
                    company_id=dto.company_id, outlet_id=dto.outlet_id, supplier_id=dto.supplier_id, po_number=po_number,
                    order_date=dto.order_date, expected_delivery_date=dto.expected_delivery_date, notes=dto.notes,
                    total_amount=po_total_amount.quantize(Decimal("0.01")), items=po_items, status='SENT'
                )
                save_po_result = await self.purchase_order_service.create_full_purchase_order(new_po, session)
                if isinstance(save_po_result, Failure): raise Exception(save_po_result.error)

                return await self._create_po_dto(save_po_result.value, supplier_result.value.name, session)
        except Exception as e:
            return Failure(f"Failed to create purchase order: {e}")

    async def receive_purchase_order_items(self, po_id: UUID, items_received: List[Dict[str, Any]], user_id: UUID) -> Result[None, str]:
        """Records the receipt of items against a purchase order."""
        try:
            async with self.core.get_session() as session:
                po = await session.get(PurchaseOrder, po_id, options=[selectinload(PurchaseOrder.items).selectinload(PurchaseOrderItem.product)])
                if not po: raise Exception(f"Purchase Order {po_id} not found.")
                if po.status not in ['SENT', 'PARTIALLY_RECEIVED']: raise Exception(f"Cannot receive items for PO in '{po.status}' status.")

                for received_item in items_received:
                    po_item = next((item for item in po.items if item.product_id == received_item['product_id']), None)
                    if not po_item: raise Exception(f"Product {received_item['product_id']} not found in PO {po_id}.")
                    
                    quantity_received = received_item['quantity_received']
                    if po_item.quantity_received + quantity_received > po_item.quantity_ordered: raise Exception(f"Received quantity for {po_item.product.sku} exceeds ordered quantity.")

                    po_item.quantity_received += quantity_received
                    adjust_res = await self.inventory_service.adjust_stock_level(po.outlet_id, po_item.product_id, po_item.variant_id, quantity_received, session)
                    if isinstance(adjust_res, Failure): raise Exception(adjust_res.error)

                    movement = StockMovement(
                        company_id=po.company_id, outlet_id=po.outlet_id, product_id=po_item.product_id, variant_id=po_item.variant_id,
                        movement_type='PURCHASE', quantity_change=quantity_received, notes=f"Received via PO {po.po_number}",
                        created_by_user_id=user_id, reference_type="PURCHASE_ORDER", reference_id=po.id
                    )
                    log_res = await self.inventory_service.log_movement(movement, session)
                    if isinstance(log_res, Failure): raise Exception(log_res.error)
                
                po.status = 'RECEIVED' if all(item.quantity_received >= item.quantity_ordered for item in po.items) else 'PARTIALLY_RECEIVED'
                return Success(None)
        except Exception as e:
            return Failure(f"Failed to receive PO items: {e}")

    async def get_inventory_summary(self, company_id: UUID, outlet_id: Optional[UUID] = None, limit: int = 100, offset: int = 0, search_term: Optional[str] = None) -> Result[List[InventorySummaryDTO], str]:
        """Retrieves a summary of inventory levels for display."""
        summary_result = await self.inventory_service.get_inventory_summary(company_id, outlet_id, limit, offset, search_term)
        if isinstance(summary_result, Failure): return summary_result
        return Success([InventorySummaryDTO(**row) for row in summary_result.value])

    async def get_all_suppliers(self, company_id: UUID) -> Result[List[SupplierDTO], str]:
        """Retrieves all active suppliers for a given company."""
        result = await self.supplier_service.get_all_active_suppliers(company_id)
        if isinstance(result, Failure): return result
        return Success([SupplierDTO.from_orm(s) for s in result.value])
    
    async def get_all_purchase_orders(self, company_id: UUID, outlet_id: Optional[UUID] = None) -> Result[List[PurchaseOrderDTO], str]:
        """Retrieves all purchase orders for a given company, optionally filtered by outlet."""
        po_results = await self.purchase_order_service.get_all_with_supplier(company_id, outlet_id)
        if isinstance(po_results, Failure):
            return po_results

        po_dtos: List[PurchaseOrderDTO] = []
        for po in po_results.value:
            supplier_name = po.supplier.name if po.supplier else "Unknown Supplier"
            po_dto_res = await self._create_po_dto(po, supplier_name)
            if isinstance(po_dto_res, Success):
                po_dtos.append(po_dto_res.value)
        return Success(po_dtos)
        
    async def get_stock_movements_for_product(self, company_id: UUID, product_id: UUID) -> Result[List[StockMovementDTO], str]:
        """
        Retrieves the movement history for a specific product.
        """
        result = await self.inventory_service.get_movements_for_product(company_id, product_id)
        if isinstance(result, Failure):
            return result
        
        return Success([StockMovementDTO(**row) for row in result.value])

    async def _create_po_dto(self, po: PurchaseOrder, supplier_name: str, session: Optional["AsyncSession"] = None) -> Result[PurchaseOrderDTO, str]:
        """Helper to construct a PurchaseOrderDTO from an ORM object."""
        items_dto: List[PurchaseOrderItemDTO] = []
        if po.items:
            product_ids = [item.product_id for item in po.items]
            # FIX: Pass session to service call
            products_res = await self.product_service.get_by_ids(product_ids, session)
            if isinstance(products_res, Failure): return products_res
            products_map = {p.id: p for p in products_res.value}

            for item in po.items:
                product = products_map.get(item.product_id)
                if not product: continue

                items_dto.append(
                    PurchaseOrderItemDTO(
                        id=item.id, product_id=item.product_id, variant_id=item.variant_id,
                        product_name=product.name, sku=product.sku, quantity_ordered=item.quantity_ordered,
                        quantity_received=item.quantity_received, unit_cost=item.unit_cost,
                        line_total=(item.quantity_ordered * item.unit_cost).quantize(Decimal("0.01"))
                    )
                )

        return Success(PurchaseOrderDTO(
            id=po.id, company_id=po.company_id, outlet_id=po.outlet_id, supplier_id=po.supplier_id,
            supplier_name=supplier_name, po_number=po.po_number, order_date=po.order_date,
            expected_delivery_date=po.expected_delivery_date, status=po.status, notes=po.notes,
            total_amount=po.total_amount, items=items_dto
        ))
